<!DOCTYPE html>
<html>
<body style="margin:0; background:black; overflow:hidden;">
    <video id="v" autoplay playsinline style="position:fixed; width:100vw; height:100vh; object-fit:cover;"></video>
    <canvas id="c" style="position:fixed; width:100vw; height:100vh; object-fit:cover; pointer-events:none;"></canvas>

    <script>
        const v = document.getElementById('v');
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');

        navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
            .then(s => { v.srcObject = s; });

        function render() {
            if (v.videoWidth > 0) {
                const w = v.videoWidth / 5;
                const h = v.videoHeight / 5;
                c.width = w; c.height = h;

                const temp = document.createElement('canvas');
                temp.width = w; temp.height = h;
                const tCtx = temp.getContext('2d');
                tCtx.drawImage(v, 0, 0, w, h);

                let f = tCtx.getImageData(0, 0, w, h);
                let d = f.data;
                
                // 1. Find all orange pixels and turn them WHITE on a BLACK background
                // This creates a "binary map" for shape detection
                for (let i = 0; i < d.length; i += 4) {
                    let r = d[i], g = d[i+1], b = d[i+2];
                    if (r > 150 && g > 60 && g < 180 && b < 100) {
                        d[i] = 255; d[i+1] = 255; d[i+2] = 255; d[i+3] = 255;
                    } else {
                        d[i] = 0; d[i+1] = 0; d[i+2] = 0; d[i+3] = 255;
                    }
                }
                
                // 2. Scan for a "Closed Box"
                // We check the top, bottom, left, and right of the orange group
                let minX = w, maxX = 0, minY = h, maxY = 0, count = 0;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let i = (y * w + x) * 4;
                        if (d[i] === 255) {
                            if (x < minX) minX = x; if (x > maxX) maxX = x;
                            if (y < minY) minY = y; if (y > maxY) maxY = y;
                            count++;
                        }
                    }
                }

                const boxW = maxX - minX;
                const boxH = maxY - minY;
                const area = boxW * boxH;

                // 3. SHAPE LOGIC:
                // If it's a box, the pixels we found should be spread out 
                // across a specific width and height. 
                // If it's just a scribble, the "density" will be wrong.
                if (count > 200 && boxW > 30 && boxH > 30 && count < area * 0.8) {
                    // It looks like a box! Apply the Black Mask
                    ctx.fillStyle = "black";
                    ctx.fillRect(minX, minY, boxW, boxH);
                    c.style.filter = "blur(10px)";
                    c.style.opacity = "1";
                } else {
                    c.style.opacity = "0";
                    ctx.clearRect(0, 0, w, h);
                }
            }
            requestAnimationFrame(render);
        }
        v.onplay = () => render();
    </script>
</body>
</html>
