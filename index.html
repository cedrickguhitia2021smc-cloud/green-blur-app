<!DOCTYPE html>
<html>
<body style="margin:0; background:black; overflow:hidden;">
    <video id="v" autoplay playsinline muted
        style="position:fixed; width:100vw; height:100vh; object-fit:cover;"></video>
    <canvas id="c"
        style="position:fixed; width:100vw; height:100vh; pointer-events:none;"></canvas>

<script>
const v = document.getElementById("v");
const c = document.getElementById("c");
const ctx = c.getContext("2d");

navigator.mediaDevices.getUserMedia({
    video: { facingMode: "environment" }
}).then(s => v.srcObject = s);

// Fixed processing resolution (important)
const SCALE = 6;
let smoothBox = null;

// RGB → HSV conversion
function rgbToHsv(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if (d === 0) h = 0;
    else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h *= 60;
    }
    return [h, s, v];
}

function render() {
    if (!v.videoWidth) return requestAnimationFrame(render);

    const w = Math.floor(v.videoWidth / SCALE);
    const h = Math.floor(v.videoHeight / SCALE);

    if (c.width !== w || c.height !== h) {
        c.width = w;
        c.height = h;
    }

    ctx.drawImage(v, 0, 0, w, h);
    let img = ctx.getImageData(0, 0, w, h);
    let d = img.data;

    let minX = w, maxX = 0, minY = h, maxY = 0;
    let count = 0;

    for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        const [H, S, V] = rgbToHsv(r, g, b);

        // ORANGE DETECTION (HSV – stable)
        if (
            H > 15 && H < 40 &&
            S > 0.55 &&
            V > 0.4
        ) {
            let x = (i / 4) % w;
            let y = Math.floor((i / 4) / w);

            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            count++;
        }
    }

    ctx.clearRect(0, 0, w, h);

    let bw = maxX - minX;
    let bh = maxY - minY;

    if (count > 300 && bw > 25 && bh > 25) {
        let target = {
            x: minX - 4,
            y: minY - 4,
            w: bw + 8,
            h: bh + 8
        };

        // Temporal smoothing (critical for stability)
        if (!smoothBox) smoothBox = target;
        smoothBox.x += (target.x - smoothBox.x) * 0.25;
        smoothBox.y += (target.y - smoothBox.y) * 0.25;
        smoothBox.w += (target.w - smoothBox.w) * 0.25;
        smoothBox.h += (target.h - smoothBox.h) * 0.25;

        // Darken / blur INSIDE the box
        ctx.save();
        ctx.filter = "blur(8px)";
        ctx.drawImage(
            v,
            smoothBox.x * SCALE,
            smoothBox.y * SCALE,
            smoothBox.w * SCALE,
            smoothBox.h * SCALE,
            smoothBox.x,
            smoothBox.y,
            smoothBox.w,
            smoothBox.h
        );
        ctx.restore();

        // Optional dark overlay
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(
            smoothBox.x,
            smoothBox.y,
            smoothBox.w,
            smoothBox.h
        );
    } else {
        smoothBox = null;
    }

    requestAnimationFrame(render);
}

v.onplay = render;
</script>
</body>
</html>
